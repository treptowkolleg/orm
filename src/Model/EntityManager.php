<?php

namespace TreptowKolleg\ORM\Model;

use PDOException;
use PDOStatement;
use TreptowKolleg\ORM\Attribute\AutoGenerated;
use TreptowKolleg\ORM\Attribute\Column;
use TreptowKolleg\ORM\Attribute\CreatedAt;
use TreptowKolleg\ORM\Attribute\Id;
use TreptowKolleg\ORM\Attribute\ManyToOne;
use TreptowKolleg\ORM\Attribute\Type;
use TreptowKolleg\ORM\Attribute\UpdatedAt;

class EntityManager
{

    private \PDO $db;
    private ?\ReflectionClass $reflectionClass;
    private ?object $entity;
    private ?string $tableName;
    private array $primaryKey = [];
    private array $columns = [];
    private array $query = [];
    private array $parameters = [];
    private array $tableColumns = [];
    private string $tpk = "";
    private array $fk = [];


    public function __construct()
    {
        $db = new Database();
        $this->db = $db->getConnection();
        $this->db->beginTransaction();
    }

    /**
     * @deprecated Funktioniert nicht, weil Datenbank bereits existieren muss.
     * @param string|null $dbName
     * @return void
     */
    public function createDatabaseIfNotExists(?string $dbName): void
    {
        $query = "CREATE DATABASE IF NOT EXISTS $dbName DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci";
        $statement = $this->db->prepare($query);
        self::execute($statement);
        $this->reset();
    }

    /**
     * Löscht die Tabelle für die angegebene Entität, falls sie existiert.
     *
     * Diese Methode akzeptiert entweder eine Entitätsinstanz oder den Namen einer Entitätsklasse.
     * Sie verwendet Reflection, um den Tabellennamen aus der Entitätsklasse zu ermitteln und
     * führt anschließend ein `DROP TABLE IF EXISTS`-Statement aus.
     *
     * @param object|string $entity Eine Instanz der Entität oder der vollständige Klassenname der Entität.
     *
     * @return void
     *
     *
     * @example
     * // Beispiel mit einem Entitätsobjekt
     * $entityManager->dropTableIfExists(new User());
     *
     * // Beispiel mit einem Klassennamen
     * $entityManager->dropTableIfExists(User::class);
     */
    public function dropTableIfExists(object|string $entity): void
    {
        if(is_string($entity)) {
            $entity = new $entity();
        }
        try {
            $this->reflectionClass = new \ReflectionClass($entity);
            $this->setTableName();
            $query = "DROP TABLE IF EXISTS {$this->tableName}";
            if(DEBUG) echo "$query\n";
            $statement = $this->db->prepare($query);
            self::execute($statement);
            $this->reset();
        } catch (\ReflectionException $e) {

        }
    }

    /**
     * Erstellt die Tabelle für die angegebene Entität, falls sie noch nicht existiert.
     *
     * Diese Methode akzeptiert entweder eine Instanz der Entität oder den vollständigen Klassennamen der Entität.
     * Sie verwendet Reflection, um die Tabellenspalten aus den Eigenschaften der Entitätsklasse zu generieren.
     * Attribute wie `Id`, `AutoGenerated`, `CreatedAt`, `UpdatedAt`, `Column` und `ManyToOne` werden berücksichtigt,
     * um die entsprechenden SQL-Definitionen für die Spalten zu erstellen. Fremdschlüssel werden ebenfalls definiert.
     *
     * @param object|string $entity Eine Instanz der Entität oder der vollständige Klassenname der Entität.
     *
     * @return void
     *
     *
     * @example
     * // Beispiel mit einem Entitätsobjekt
     * $entityManager->createTableIfNotExists(new User());
     *
     * // Beispiel mit einem Klassennamen
     * $entityManager->createTableIfNotExists(User::class);
     *
     * @note Die Methode startet eine Transaktion, falls keine aktive Transaktion vorhanden ist.
     *       Das erstellte SQL-Statement wird im DEBUG-Modus ausgegeben.
     */
    public function createTableIfNotExists(object|string $entity): void
    {
        if(is_string($entity)) {
            $entity = new $entity();
        }
        try {
            $this->reflectionClass = new \ReflectionClass($entity);
        } catch (\ReflectionException $e) {

        }
        $this->entity = $entity;
        if(!$this->db->inTransaction())
            $this->db->beginTransaction();
        $this->setTableName();
        foreach ($this->reflectionClass->getProperties() as $property) {
            $attributes = $property->getAttributes();
            $propertyName = $this->generateSnakeTailString($property->getName());
            foreach ($attributes as $attribute) {
                $attribute = $attribute->newInstance();
                if ($attribute instanceof Id) {
                    $this->tpk = "PRIMARY KEY ($propertyName)";
                }
                if ($attribute instanceof AutoGenerated) {
                    $this->tableColumns[$propertyName]["ai"] = "AUTO_INCREMENT";
                }
                if($attribute instanceof CreatedAt) {
                    $this->tableColumns[$propertyName]["extra"] = "DEFAULT CURRENT_TIMESTAMP";
                    $this->tableColumns[$propertyName]["type"] = "DATETIME";
                    $this->tableColumns[$propertyName]["null"] = "NOT NULL";
                    $this->tableColumns[$propertyName]["unique"] = "";
                }
                if($attribute instanceof UpdatedAt) {
                    $this->tableColumns[$propertyName]["extra"] = "ON UPDATE CURRENT_TIMESTAMP";
                    $this->tableColumns[$propertyName]["type"] = "DATETIME";
                    $this->tableColumns[$propertyName]["null"] = "NULL";
                    $this->tableColumns[$propertyName]["unique"] = "";
                }
                if ($attribute instanceof Column) {
                    $this->tableColumns[$propertyName]["type"] = match ($attribute->getType()){
                        Type::Integer, Type::ManyToOne => "INT",
                        Type::OneToMany, Type::ManyToMany => null,
                        Type::String, Type::Password => "VARCHAR",
                        Type::Boolean => "TINYINT",
                        Type::DateTime => "DATETIME",
                        Type::Date => "DATE",
                        Type::Json => "JSON",
                        Type::Text => "TEXT",
                        Type::MediumText => "MEDIUMTEXT",
                        Type::LongText => "LONGTEXT",
                    };
                    if($attribute->getType() == Type::String){
                        $this->tableColumns[$propertyName]["type"] .= "({$attribute->getLength()})";
                    }
                    if($attribute->getType() == Type::Json){
                        $this->tableColumns[$propertyName]["null"] = "";
                    }
                    if($attribute->getType() != Type::Json) {
                        $this->tableColumns[$propertyName]["null"] = $attribute->isNullable() ? "NULL" : "NOT NULL";
                    }
                    $this->tableColumns[$propertyName]["unique"] = $attribute->isUnique() ? "UNIQUE" : "";
                    $this->tableColumns[$propertyName]["extra"] = "";
                }
                if ($attribute instanceof ManyToOne) {
                    $table = $this->generateSnakeTailString($attribute->getTargetEntity()->getShortName());
                    $column = $this->generateSnakeTailString($attribute->getTargetColumn());
                    $this->fk[$table]["fk"] = $column;
                    $this->fk[$table]["column"] = $propertyName;
                }
            }
        }

        $query = "CREATE TABLE IF NOT EXISTS $this->tableName (";
        foreach ($this->tableColumns as $name => $content) {
            $query .= "$name {$content["type"]} {$content["null"]} {$content["unique"]} {$content["extra"]}";
            if(array_key_exists("ai", $content)) {
                $query .= " {$content["ai"]}";
            }
            $query .= ",";
        }
        $query .= $this->tpk;
        foreach ($this->fk as $table => $column) {
            $query .= ", FOREIGN KEY ({$column["column"]}) REFERENCES $table({$column["fk"]})";
        }
        $query .= ")";
        $query .= "DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci";

        if(DEBUG) echo "$query\n";
        $statement = $this->db->prepare($query);
        self::execute($statement);
        $this->reset();
    }

    private function execute(PDOStatement $statement): void
    {
        try {
            $statement->execute();
            $statement->closeCursor();
        } catch (PDOException $e) {
            echo $e->getMessage() . PHP_EOL;
        }
    }

    /**
     * Speichert eine Entität in der Datenbank, indem sie entweder eingefügt oder aktualisiert wird.
     *
     * Diese Methode überprüft anhand des `Id`-Attributes, ob die Entität bereits eine ID hat:
     * - Wenn die ID vorhanden ist, wird ein `UPDATE` ausgeführt.
     * - Wenn die ID nicht vorhanden ist, wird ein `INSERT` ausgeführt.
     *
     * Vor der Speicherung wird eine Transaktion gestartet, falls keine aktive Transaktion vorhanden ist.
     *
     * @param object $entity Die Entität, die in der Datenbank gespeichert werden soll.
     *
     * @return void
     *
     *
     * @example
     * // Beispiel mit einer neuen Entität (INSERT)
     * $user = new User();
     * $user->setName('Max Mustermann');
     * $entityManager->persist($user);
     *
     * // Beispiel mit einer vorhandenen Entität (UPDATE)
     * $user = $repository->find(1);
     * $user->setName('Anna Müller');
     * $entityManager->persist($user);
     *
     * @note Die Methode entscheidet automatisch, ob ein INSERT oder UPDATE ausgeführt wird,
     *       basierend auf der Präsenz eines `Id`-Wertes in der Entität.
     */
    public function persist(object $entity): void
    {
        try {
            $this->reflectionClass = new \ReflectionClass($entity);
            $this->entity = $entity;
            $properties = $this->reflectionClass->getProperties();
            if(!$this->db->inTransaction())
                $this->db->beginTransaction();
            foreach ($properties as $property) {
                if(!empty($property->getAttributes(Id::class))) {
                    if (null != $property->getValue($entity)) {
                        $this->update();
                    } else {
                        $this->insert();
                    }
                    break;
                }
            }

        } catch (\ReflectionException $e) {

        }
    }

    private function reset(): void
    {
        $this->reflectionClass = null;
        $this->entity = null;
        $this->tableName = null;
        $this->primaryKey = [];
        $this->columns = [];
        $this->query = [];
        $this->parameters = [];
        $this->tableColumns = [];
        $this->tpk = "";
        $this->fk = [];
        if(!$this->db->inTransaction())
            $this->db->beginTransaction();
    }

    /**
     * Bestätigt alle ausstehenden Datenbanktransaktionen.
     *
     * Diese Methode führt einen `COMMIT` für die aktuelle Datenbanktransaktion aus.
     * Alle Änderungen, die seit dem letzten `beginTransaction()` vorgenommen wurden,
     * werden dauerhaft in der Datenbank gespeichert.
     *
     * @return void
     *
     * @throws PDOException Falls ein Fehler beim Commit der Transaktion auftritt.
     *
     * @example
     * // Beispiel für die Verwendung von persist() und flush()
     * $user = new User();
     * $user->setName('Max Mustermann');
     * $entityManager->persist($user);
     * $entityManager->flush(); // Bestätigt die Transaktion und speichert die Änderungen
     *
     * @note Es ist notwendig, `flush()` aufzurufen, nachdem `persist()` verwendet wurde,
     *       um sicherzustellen, dass die Änderungen tatsächlich in der Datenbank gespeichert werden.
     */
    public function flush(): void
    {
        $this->db->commit();
    }

    /**
     * Bricht die aktuelle Datenbanktransaktion ab und macht alle Änderungen rückgängig.
     *
     * Diese Methode führt einen `ROLLBACK` aus, um alle seit dem letzten `beginTransaction()`
     * vorgenommenen Änderungen rückgängig zu machen. Sie wird verwendet, wenn während der Transaktion
     * ein Fehler auftritt oder die Änderungen nicht gespeichert werden sollen.
     *
     * @return void
     *
     * @throws PDOException Falls ein Fehler beim Zurückrollen der Transaktion auftritt.
     *
     * @example
     * // Beispiel für die Verwendung von persist(), flush() und rollback()
     * try {
     *     $user = new User();
     *     $user->setName('Max Mustermann');
     *     $entityManager->persist($user);
     *     $entityManager->flush();
     * } catch (\Exception $e) {
     *     $entityManager->rollback(); // Setzt die Transaktion zurück bei einem Fehler
     *     echo "Fehler: " . $e->getMessage();
     * }
     *
     * @note Diese Methode sollte nur verwendet werden, wenn sich die Datenbank in einem Transaktionszustand befindet.
     *       Ein Aufruf ohne aktive Transaktion führt zu einer Fehlermeldung.
     */
    public function rollback(): void
    {
        $this->db->rollBack();
    }

    private function update(): void
    {
        $this->setTableName();
        $this->setColumns(true);
        $this->createQuery(true);
    }

    private function insert(): void
    {
        $this->setTableName();
        $this->setColumns();
        $this->createQuery();
    }

    private function createQuery(bool $update = false): void
    {
        if(!$update) {
            $this->query[] = "INSERT INTO {$this->tableName}";
            $this->query[] = "(" . implode(", ", $this->columns) . ")";
            $this->query[] = "VALUES";
            $this->query[] = "(" . implode(", ", array_keys($this->parameters)) . ")";
        } else {
            $this->query[] = "UPDATE {$this->tableName} SET";
            $string = "";
            foreach($this->parameters as $key => $value) {
                $key = ltrim($key, ":");
                $string .= "$key=:$key, ";
            }
            $this->query[] = rtrim($string, ", ");
            $keys = array_keys($this->primaryKey); $keyName = array_shift($keys);
            $this->query[] = "WHERE $keyName=:$keyName";
        }
        $statement = $this->db->prepare($query =implode(" ", $this->query));

        if(DEBUG) echo "$query\n";

        foreach($this->parameters as $key => $value) {
            $statement->bindValue($key, $value);
            if(DEBUG) echo "$key: $value\n";
        }
        if($update) $statement->bindValue(":" . key($this->primaryKey),$this->primaryKey[key($this->primaryKey)]);
        self::execute($statement);
        $this->reset();
    }

    private function setTableName(): void
    {
        $this->tableName = $this->generateSnakeTailString($this->reflectionClass->getShortName());
    }

    private function setColumns(bool $update = false): void
    {
        foreach ($this->reflectionClass->getProperties() as $property) {
            if(!empty($property->getAttributes(Column::class)) and empty($property->getAttributes(AutoGenerated::class)))
            {
                $value = ($property->getType() == 'bool' and !$property->getValue($this->entity)) ? 0 : $property->getValue($this->entity);
                $this->columns[] = $parameter = $this->generateSnakeTailString($property->getName());
                $this->parameters[":$parameter"] = $value;
            }
            elseif ($update and !empty($property->getAttributes(Column::class)) and !empty($property->getAttributes(AutoGenerated::class)))
            {
                $value = ($property->getType() == 'bool' and !$property->getValue($this->entity)) ? 0 : $property->getValue($this->entity);
                $keyName = $this->generateSnakeTailString($property->getName());
                $this->primaryKey[$keyName] = $value;
            }
        }
    }

    public function generateSnakeTailString(string $value): string
    {
        $valueAsArray = preg_split('/(?=[A-Z])/', $value);
        return strtolower(ltrim(implode('_', $valueAsArray),'_'));
    }

}